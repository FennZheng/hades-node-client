// Generated by CoffeeScript 1.3.3
(function() {
  var CONFIG_ROOT_PATH, CountDownLatch, RemoteConfigCache, ZkProxy, event, zkConfig, zookeeper, _i, _len, _ref;

  zookeeper = require('node-zookeeper-client');

  zkConfig = require('../../setting/hades_config.json');

  RemoteConfigCache = require('../config/remote_config_cache').RemoteConfigCache;

  CONFIG_ROOT_PATH = "/hades/configs";

  this._event = {
    EVENT_ALL_LOAD_COMPLETE: "ALL_LOAD_COMPLETE",
    EVENT_ALL_LOAD_TIMEOUT: "ALL_LOAD_TIMEOUT",
    _EVENT_ITEM_LOAD_COMPLETE: "ITEM_LOAD_COMPLETE",
    _EVENT_LOAD_ERROR: "LOAD_ERROR"
  };

  ZkProxy = (function() {

    util.inherits(ZkProxy, Event.EventEmitter);

    ZkProxy.on(ZkProxy._EVENT_ITEM_LOAD_COMPLETE, function(name, data) {
      if (data != null) {
        RemoteConfigCache[name] = data;
      } else {

      }
      return delete RemoteConfigCache[name];
    });

    ZkProxy.on(ZkProxy._EVENT_LOAD_ERROR, function(err) {
      return console.log("LOAD ERROR:" + err.stack);
    });

    function ZkProxy() {
      if (!(zkConfig.project != null)) {
        throw new Error("init error: project is null or hostList is null");
      }
      this._loadCompleted = false;
      this._PROJECT_PATH = CONFIG_ROOT_PATH + "/" + zkConfig.project;
      this._hostList = zkConfig.hostList;
      this._retries = zkConfig.retries || 3;
      this._sessionTimeout = zkConfig.sessionTimeout || 10000;
      this._loadTimeout = zkConfig.loadTimeout || 10000;
      this._client = zookeeper.createClient(this._hostList, {
        retries: this._retries,
        sessionTimeout: this._sessionTimeout
      });
      return;
    }

    ZkProxy.prototype.checkLoadState = function() {
      return this._loadCompleted;
    };

    ZkProxy.prototype.load = function() {
      this._loadCompleted = false;
      this._setLoadTimeoutCheck();
      this._client.connect();
      return this._client.getChildren(this._PROJECT_PATH, this._initConfigMap.bind(this));
    };

    ZkProxy.prototype._initConfigMap = function(err, children, stats) {
      var child, _countDownLatch, _i, _len, _results;
      RemoteConfigCache = {};
      if (err) {
        this.emit(this._EVENT_LOAD_ERROR, err);
      }
      if (children != null) {
        _countDownLatch = new CountDownLatch(children.length, function() {
          this._loadCompleted = true;
          return this.emit(this.EVENT_ALL_LOAD_COMPLETE);
        });
        _results = [];
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          _results.push(this._loadConfigItem(child, _countDownLatch));
        }
        return _results;
      }
    };

    ZkProxy.prototype._loadConfigItem = function(name, _countDownLatch) {
      var _path;
      _path = this._buildPath(name);
      this._client.getData(_path, null, function(err, data, stat) {
        if (err) {
          this.emit(this._EVENT_LOAD_ERROR, err);
        } else {
          this.emit(this._EVENT_ITEM_LOAD_COMPLETE, name, data);
        }
        _countDownLatch.countDown();
      });
    };

    ZkProxy.prototype._buildPath = function(configName) {
      return this._PROJECT_PATH + "/" + configName;
    };

    ZkProxy.prototype._setLoadTimeoutCheck = function() {
      return setTimeout(function() {
        if (!this._loadCompleted) {
          this.emit(this._EVENT_LOAD_ERROR, new Error("load all configs timeout , except finished in " + this._loadTimeout));
          return this.emit(this.EVENT_ALL_LOAD_TIMEOUT);
        }
      }, this._loadTimeout);
    };

    return ZkProxy;

  })();

  CountDownLatch = (function() {

    function CountDownLatch(count, submit) {
      this._count = count;
      this._submit = submit;
    }

    CountDownLatch.prototype.countDown = function() {
      this._count = this._count(-1);
      if (this._count <= 0) {
        this._submit();
      }
      return this._count;
    };

    return CountDownLatch;

  })();

  exports.ZkProxy = new ZkProxy();

  _ref = this._event;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    event = _ref[_i];
    exports[event.key] = event.value;
  }

}).call(this);
